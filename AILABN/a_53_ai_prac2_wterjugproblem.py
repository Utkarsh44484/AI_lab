# -*- coding: utf-8 -*-
"""A_53_AI_Prac2_WterJugProblem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/111TdW4cznoV4zwXUrqhwZwxoMNWlFcxV

# Artificial Intelligence Lab 

---



### Practical 2 - Water Jug Problem

### Name: Prathamesh Rajbhoj

### Roll No: A - 53



---

## Search Technique Used : Breadth First Search
"""

# options : afull, bfull, aempty, bempty, atransfer, btransfer

def bfs(curr_a, curr_b, max_a, max_b, req_a, req_b):

  ans = -1

  queue = []
  visited = set()
  parent = {(curr_a,curr_b) : (-1,-1)}

  queue.append((curr_a, curr_b))
  visited.add((curr_a, curr_b))

  par = (-1,-1)

  while(len(queue) > 0):

    qsize = len(queue)

    # print(f'queue = {queue}')

    ans = ans + 1

    if(ans > 20):
      return -1

    for loop in range(qsize):

      state = queue[0]
      queue.pop(0)

      a = state[0]
      b = state[1]

      if(a == req_a and b==req_b):
        return ans, parent

      x1,y1 = (max_a, b)
      x2,y2 = (a, max_b)
      x3,y3 = (0, b)
      x4,y4 = (a, 0)

      total = a+b
      filla = min(max_a, total)
      fillb = total - filla
      fillb = min(fillb, max_a)
                  
      x5,y5 = (filla, fillb)

      total = a+b
      fillb = min(max_b, total)
      filla = total - fillb
      filla = min(filla, max_a)
                  
      x6,y6 = (filla, fillb)

      options = [(x1,y1), (x2,y2), (x3,y3), (x4,y4), (x5,y5), (x6,y6)]

      # print(f'options for {a} , {b} : {options}')


      for i in options:
        if i not in visited:
          # print(f'loop --> {i}')
          parent[i] = state
          visited.add(i)
          queue.append(i)

def printPath(steps, parent, req_a, req_b):

  child = (req_a, req_b)
  path = []

  while(child != (-1,-1)):
    path.append(child)
    child = parent[child]

  path.reverse()

  print(f'\nPath to reach ({req_a},{req_b}) is : {path}')

max_a = 4
max_b = 3

req_a = 2
req_b = 0

curr_a = 0
curr_b = 0

######################################################################################

curr_a = max_a
curr_b = 0

steps, parent = bfs(curr_a, curr_b, max_a, max_b, req_a, req_b)

if(steps == -1):
  print("Solution not found")
else:
  print(steps)
  # print(parent)

  printPath(steps, parent, req_a, req_b)

print("\n\n")
######################################################################################

curr_a = 0
curr_b = max_b

steps, parent = bfs(curr_a, curr_b, max_a, max_b, req_a, req_b)

if(steps == -1):
  print("Solution not found")
else:
  print(steps)
  # print(parent)

  printPath(steps, parent, req_a, req_b)

"""## Printing Recursion Tree"""

# # options : afull, bfull, aempty, bempty, atransfer, btransfer

# def helper(a, b, amax, bmax, areq, breq, count, visited):

#     if(visited[a][b]==1):
#       return

#     visited[a][b]=1
    
#     print(a,b)
    
#     count=count+1
#     if(count>100):
#         return False
    
#     if(a==areq and b==breq):
#         return True
    
#     if(a<0 or b<0 or a>amax or b>bmax):
#         return False
    
#     if(a==amax and b==bmax):
#         return False
    
    
    
    
    
    
#     if(a!=amax and helper(amax, b, amax, bmax, areq, breq, count, visited)):
#         return True
    
#     if(b!=bmax and helper(a, bmax, amax, bmax, areq, breq, count, visited)):
#         return True
    
#     if(a!= 0 and helper(0, b, amax, bmax, areq, breq, count, visited)):
#         return True
    
#     if(b!=0 and helper(a, 0, amax, bmax, areq, breq, count, visited)):
#         return True

#     tempb = min(bmax, a+b)
#     added_in_b = tempb - b
#     rem_in_a = a - added_in_b;
    
#     if(a!=0 and helper(rem_in_a, tempb, amax, bmax, areq, breq, count, visited)):
#         return True
    
    
#     tempa = min(amax, a+b)
#     added_in_a = tempa - a
#     rem_in_b = b - added_in_a
    
#     if(b!=0 and helper(tempa, rem_in_b, amax, bmax, areq, breq, count, visited)):
#         return True
    
    
#     return False

# amax = 4
# bmax = 3

# areq = 2
# breq = 0

# curr_a = 0
# curr_b = 0

# count = 0

# visited = []

# for i in range(amax):
#   lst = []
#   for j in range(bmax):
#     lst.append(0)
#   visited.append(lst)


# isPossible = helper(curr_a, curr_b, amax, bmax, areq, breq, 0, visited)

# print(isPossible)