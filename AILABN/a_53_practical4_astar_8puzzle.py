# -*- coding: utf-8 -*-
"""A_53_Practical4_Astar_8puzzle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sWir_3wTekXJJS8mdvEpjgdEV_769ULD
"""

# 8 PUZZLE PROBLEM

import heapq

# input = [
#     [1,2,3],
#     [4,0,5],
#     [7,8,6]
# ]


# output = [
#     [1,2,3],
#     [4,5,6],
#     [7,8,0]
# ]

# formula : f(n) = g(n) + h(n)

def calculateHueristic_1(inp, out):
    ans = 0
    
    for i in range(3):
        for j in range(3):
            if(inp[i][j] != out[i][j]):
                ans=ans+1
    
    return ans

def flatten(inp):
    ans = ""
    for i in inp:
        for j in i:
            ans = ans + str(j)
            
    return ans

# print(flatten(input))

def moveUP(grid1):
    
    grid = grid1
    
    x=0
    y=0
    
    for i in range(3):
        for j in range(3):
            if(grid[i][j]==0):
                x=i
                y=j
    
    if(x==0):
        return grid
    
    grid[x][y]=grid[x-1][y]
    grid[x-1][y]=0
    
    return grid

################################################################

def moveDOWN(grid1):
    
    grid = grid1
    
    x=0
    y=0
    
    for i in range(3):
        for j in range(3):
            if(grid[i][j]==0):
                x=i
                y=j
    
    if(x==2):
        return grid
    
    grid[x][y]=grid[x+1][y]
    grid[x+1][y]=0
    
    return grid
################################################################

def moveLEFT(grid1):
    
    grid = grid1
    
    x=0
    y=0
    
    for i in range(3):
        for j in range(3):
            if(grid[i][j]==0):
                x=i
                y=j
    
    if(y==0):
        return grid
    
    grid[x][y]=grid[x][y-1]
    grid[x][y-1]=0
    
    return grid

################################################################

def moveRIGHT(grid1):
    
    grid = grid1
    
    x=0
    y=0
    
    for i in range(3):
        for j in range(3):
            if(grid[i][j]==0):
                x=i
                y=j
    
    if(y==2):
        return grid
    
    grid[x][y]=grid[x][y+1]
    grid[x][y+1]=0
    
    return grid

################################################################

# print(input)
# print(moveUP(input))
# print(moveDOWN(input))
# print(moveLEFT(input))
# print(moveRIGHT(input))

open = []
close = set()
heapq.heapify(open)

input = [
    [0,1,2],
    [4,5,3],
    [7,8,6]
]


output = [
    [1,2,3],
    [4,5,6],
    [7,8,0]
]


heapq.heappush(open, (0,1,input))
close.add(flatten(input))

print("The created heap is : ", end="")
print(open)
print(close)

def copygrid(grid):
    temp = []
    for i in grid:
        lst=[]
        for j in i:
            lst.append(j)
        temp.append(lst)
    
    return temp

# applying A star algorithm



while(len(open)>0):
    curr = heapq.heappop(open)
    value = curr[0]
    level = curr[1]
    grid = curr[2]
    
    print(curr)
    
    if(grid == output):
        break
        
        
        
    
    #print(value, level, grid)
    
    temp = copygrid(grid)
    grid_up = moveUP(temp)
    
    temp = copygrid(grid)
    grid_down = moveDOWN(temp)  
    
    temp = copygrid(grid)
    grid_left = moveLEFT(temp)
    
    temp = copygrid(grid)
    grid_right = moveRIGHT(temp)
    
#     print(grid_up, "\n", grid_down, "\n", grid_left, "\n", grid_right)
    
#     print("up", moveUP(grid))
#     print("test2", grid_up)
    
#     print("down", moveDOWN(grid))
#     print("test2", grid_down)
    
#     print("left", moveLEFT(grid))
#     print("test2", grid_down)
    
#     print("right", moveRIGHT(grid))
#     print("test2", grid_down)
    
        
    grid_up_h = calculateHueristic_1(grid_up, output)
    grid_down_h = calculateHueristic_1(grid_down, output)
    grid_left_h = calculateHueristic_1(grid_left, output)
    grid_right_h = calculateHueristic_1(grid_right, output)
    
#     print("up : ", grid_up, grid_up_h)
#     print("down : ", grid_down, grid_down_h)
#     print("left : ", grid_left, grid_left_h)
#     print("right : ", grid_right, grid_right_h)
    
    
    if(grid_up != -1 and flatten(grid_up) not in close):
        heapq.heappush(open, ( level+grid_up_h , level+1, grid_up ))
        close.add(flatten(grid_up))
    
    if(grid_down != -1 and flatten(grid_down) not in close):
        heapq.heappush(open, ( level+grid_down_h , level+1, grid_down ))
        close.add(flatten(grid_up))
        
    if(grid_left != -1 and flatten(grid_left) not in close):
        heapq.heappush(open, ( level+grid_left_h , level+1, grid_left ))
        close.add(flatten(grid_up))
        
    if(grid_right != -1 and flatten(grid_right) not in close):
        heapq.heappush(open, ( level+grid_right_h , level+1, grid_right ))
        close.add(flatten(grid_up))

